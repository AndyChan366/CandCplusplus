/*小明是快递公司的员工。现在他面前有很多包裹，每个包裹都有唯一的数字编号，代表包裹投递的优先级。
目前这些包裹已经整齐地排成一列，但是并没有按照编号顺序排好。
为了投递方便，小明想弄清包裹投递的先后顺序，为此他想出了一个办法，能够将包裹按照编号从小到大的顺序重新排列。
首先，他将包裹分为两部分，有序部分(S)和无序部分(U)，最初S仅包含第一个包裹，U包含剩余所有包裹。
小明每次挑出U中的第一个包裹U(1)，将这个包裹的编号与S中所有包裹的编号依次做比较，比较时按照以下规则：
若U(1)大于S中最后的包裹, 则说明U(1)大于S中所有包裹，此时不需要移动包裹U(1)，仅仅需要将U(1)从U中除去，并入S尾部；
否则，从S排在最后的包裹开始，依次向前比较，直到U(1)的编号大于S(i)且小于S(i+1)，此时将U(1)插到S(i)和S(i+1)之间。
不管遇到上面两种情况中的哪一种，S中包裹的数量都增加了一个，U中包裹的数量减少了一个。
重复执行上述过程，当S中包裹的数量等于包裹总数，而U中包裹数量为0时，小明就能按照重新排列后的包裹顺序投递包裹了。
假设在遇到上述第2种情况时，小明需要花5秒钟将U(1)插到S(i)和S(i+1)之间。不考虑其他耗时，请帮小明计算一下排列所有包裹需要花费的时间。
输入：
第一行为T（1<=T<=20），代表用例个数。
接下来每个测试用例，首先输入N（1<=N<=10000），代表包裹个数，接着输入每个包裹的编号Mi。
输出：
输出一个整数，代表小明排列包裹需要花费的秒数。
样例输入：
1
6
5 2 1 6 4 3
样例输出：
20*/
#include<iostream>
using namespace std;
int main(){
    int N,n,num,max,times;
    cin>>N;
    for(int i=0;i<N;i++){
        times=0;
        cin>>n;
        cin>>max;
        for(int i=1;i<n;i++){
            cin>>num;
            if(max<num){
                max=num;  
            }
            else{
                times+=5;                
            }
        }  
        cout<<times<<endl;   
    }
    return 0;    
}